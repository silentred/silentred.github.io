<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>寒江夜钓</title>
  
  <subtitle>Gopher &amp; linuxer, 关注基础架构，分布式，高并发，高可用。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2020-11-02T02:37:19.834Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>NightsWatch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Percolator 学习笔记</title>
    <link href="http://localhost:4000/2019/03/16/percolator/"/>
    <id>http://localhost:4000/2019/03/16/percolator/</id>
    <published>2019-03-16T15:04:09.000Z</published>
    <updated>2020-11-02T02:37:19.834Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近去 PingCAP 杭州分舵听了 TiDB事务 的分享, 模型使用的是 Percolator，听着比较简单，回来补下论文，看看有什么遗漏.</p></blockquote><a id="more"></a><h1 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h1><h2 id="Subtitle"><a href="#Subtitle" class="headerlink" title="Subtitle"></a>Subtitle</h2><h2 id="Subtitle-1"><a href="#Subtitle-1" class="headerlink" title="Subtitle"></a>Subtitle</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近去 PingCAP 杭州分舵听了 TiDB事务 的分享, 模型使用的是 Percolator，听着比较简单，回来补下论文，看看有什么遗漏.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="database" scheme="http://localhost:4000/categories/tech/database/"/>
    
    
      <category term="database" scheme="http://localhost:4000/tags/database/"/>
    
      <category term="transaction" scheme="http://localhost:4000/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>改变</title>
    <link href="http://localhost:4000/2019/01/16/new-age/"/>
    <id>http://localhost:4000/2019/01/16/new-age/</id>
    <published>2019-01-16T03:32:00.000Z</published>
    <updated>2019-01-16T03:47:28.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于这个博客的改变</p></blockquote><a id="more"></a><p>之前一直想打造精品博客，现在想法变了，想到什么就写什么，除了技术，还会有很多吐槽。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于这个博客的改变&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://localhost:4000/categories/life/"/>
    
    
      <category term="life" scheme="http://localhost:4000/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Go Assembly 学习笔记</title>
    <link href="http://localhost:4000/2017/09/02/go-asm/"/>
    <id>http://localhost:4000/2017/09/02/go-asm/</id>
    <published>2017-09-02T07:56:48.000Z</published>
    <updated>2019-01-10T06:30:49.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近升级 go1.9，发现一个获取 goroutine id 的依赖没有支持1.9，于是手动写了一个，顺便学习一下 go assembly。希望你看完这篇文章后，对go汇编有一定的了解。</p></blockquote><a id="more"></a><h1 id="Go-Assembly"><a href="#Go-Assembly" class="headerlink" title="Go Assembly"></a>Go Assembly</h1><p>首先安利一个获取当前goroutine id 的library, <a href="http://github.com/silentred/gid">gid</a>，支持 go1.7 - go1.9, 可能是目前最小的库了，使用也很简单: <code>id := gid.Get()</code>。</p><p>Go汇编语法类似 Plan 9，它不是对机器语言的直接表达，拥有半抽象的指令集。总体来说， machine-specific 操作一般就是它们的本意，其他概念例如 memory move, subroutine call, return 是抽象的表达。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>evaluation 优先级和 C 不同，例如 3&amp;1&lt;&lt;2 == 4, 解释为 (3&amp;1) &lt;&lt; 2。<br>常量被认为是 unsigned 64-bit int, 因此 -2 不是负数，而是被作为 uint64 解读。</p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>4个预定义的符号，表示 pseudo-registers, 伪寄存器（虚拟寄存器？）。</p><ul><li>FP: frame pointer, 参数和本地变量</li><li>PC: program counter: 跳转，分支</li><li>SB: static base pointer: 全局符号</li><li>SP: stack pointer: 栈顶</li></ul><p>用户定义的符号都是通过偏移(offset)来表示的。</p><p>SB寄存器表示全局内存起点，foo(SB) 表示 符号foo作为内存地址使用。这种形式用于命名 全局函数，数据。<code>&lt;&gt;</code>限制符号只能在当前源文件使用，类似 C 中的 static。<code>foo+4(SB)</code>表示foo 往后 4字节的地址。</p><p>FP寄存器指向函数参数。0(FP)是第一个参数，8(FP)是第二个参数(64-bit machine). <code>first_arg+0(FP)</code>表示把第一个参数地址绑定到符号 first_arg, 这个与SB的含义不同。</p><p>SP寄存器表示栈指针，指向 top of local stack frame, 所以 offset 都是负数，范围在 [ -framesize, 0 ), 例如 x-8(SP). 对于硬件寄存器名称为SP的架构，<code>x-8(SP)</code> 表示虚拟栈指针寄存器， <code>-8(SP)</code> 表示硬件 SP 寄存器.</p><p>跳转和分支是针对PC的offset，或者 label, 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">MOVW $0, R1</span><br><span class="line">JMP label</span><br></pre></td></tr></table></figure><p>label 范围是函数级别的，不同函数可以定义相同名称的label。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·profileloop(SB),NOSPLIT,$8</span><br><span class="line">MOVQ$runtime·profileloop1(SB), CX</span><br><span class="line">MOVQCX, 0(SP)</span><br><span class="line">CALLruntime·externalthreadhandler(SB)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>TEXT 指令定义符号 <code>runtime·profileloop</code>, RET 表示结尾，如果没声明，linker会添加 jump-to-self 指令。<br>$8 表示 frame size,一般后面需要加上参数大小。这里因为有 NOSPLIT，可以不加。</p><p>全局数据符号用 DATA 声明，方式为 <code>DATA    symbol+offset(SB)/width, value</code><br>GLOBL 定义数据为全局。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA divtab&lt;&gt;+0x00(SB)&#x2F;4, $0xf4f8fcff</span><br><span class="line">DATA divtab&lt;&gt;+0x04(SB)&#x2F;4, $0xe6eaedf0</span><br><span class="line">...</span><br><span class="line">DATA divtab&lt;&gt;+0x3c(SB)&#x2F;4, $0x81828384</span><br><span class="line">GLOBL divtab&lt;&gt;(SB), RODATA, $64</span><br><span class="line"></span><br><span class="line">GLOBL runtime·tlsoffset(SB), NOPTR, $4</span><br></pre></td></tr></table></figure><p>定义并初始化了 divtab&lt;&gt;, 一个 只读的 64字节 表，每一项4字节。定义了 runtime·tlsoffset， 4字节空值，非指针。</p><p>指令有一个或两个参数。如果有两个，第一个是 bit mask, 可以为数字表达式。值的定义如下：</p><ul><li>NOPROF = 1 ; (For TEXT items.) Don’t profile the marked function. This flag is deprecated. 废弃</li><li>DUPOK = 2 ; It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use. 此符号允许存在多个，链接器选择其一使用。</li><li>NOSPLIT = 4 ; (For TEXT items.) Don’t insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space at the top of the stack segment. Used to protect routines such as the stack splitting code itself. 不插入代码，不检查是否需要 stack split. (疑问，高版本go使用连续栈，这个指令还有作用吗？)</li><li>RODATA = 8 ; (For DATA and GLOBL items.) Put this data in a read-only section. 数据存入只读区</li><li>NOPTR = 16 ; (For DATA and GLOBL items.) This data contains no pointers and therefore does not need to be scanned by the garbage collector. 表示非指针，不需要 GC。</li><li>WRAPPER = 32 ; (For TEXT items.) This is a wrapper function and should not count as disabling recover. </li><li>NEEDCTXT = 64 ; (For TEXT items.) This function is a closure so it uses its incoming context register.</li></ul><h1 id="Example-Add"><a href="#Example-Add" class="headerlink" title="Example: Add"></a>Example: Add</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int64</span>)</span> <span class="title">int64</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; add.s</span><br><span class="line">TEXT ·add(SB),$0-24</span><br><span class="line">    MOVQ x+0(FP), BX</span><br><span class="line">MOVQ y+8(FP), BP</span><br><span class="line">    ADDQ BP, BX</span><br><span class="line">    MOVQ BX, ret+16(FP)</span><br><span class="line">    RET</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义一个函数的方式为： <code>TEXT package_name·function_name(SB),$frame_size-arguments_size</code><br>例子中 package_name 是空，表示当前package。 之后是一个 middle point(U+00B7) 和 函数名称。<br>frame_size 是 $0, 表示了需要 stack 的空间大小，这里是0， 表示不需要stack，只使用 寄存器。函数的参数和返回值的大小为 <code>3 * 8 = 24</code> bytes。</p><p><code>MOVQ</code> 表示移动一个 64bit 的值(Q 代表 quadword)。这里是从 FP(frame pointer, 指向 函数参数的起始位置) 移动到 <code>BX</code> 和 <code>BP</code>. 语法 <code>symbol+offset(register)</code> 中的 offset, 代表了从 register 为起点，移动 offset后的地址。这里的 x, y 是在函数定义中的参数符号。</p><p><code>ADDQ</code> 那一行指令 表示把两个 64bit register的值相加，存到 BX。</p><p>最后的 <code>MOVQ</code> 把 BX 中的值，移动到 FP+16的位置， 这里的 <code>ret</code> 符号是编译器默认的返回值符号。</p><h1 id="Example-Hello"><a href="#Example-Hello" class="headerlink" title="Example: Hello"></a>Example: Hello</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line"></span><br><span class="line">DATA world&lt;&gt;+0(SB)&#x2F;8, $&quot;hello wo&quot;</span><br><span class="line">DATA world&lt;&gt;+8(SB)&#x2F;4, $&quot;rld &quot;</span><br><span class="line"></span><br><span class="line">GLOBL world&lt;&gt;+0(SB), RODATA, $12</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 需要 stack空间 88字节，没有参数和返回值</span><br><span class="line">TEXT ·hello(SB),$88-0</span><br><span class="line">SUBQ$88, SP</span><br><span class="line">MOVQBP, 80(SP)</span><br><span class="line">LEAQ80(SP), BP</span><br><span class="line">    &#x2F;&#x2F; 创建字符，存在 my_string</span><br><span class="line">    LEAQworld&lt;&gt;+0(SB), AX </span><br><span class="line">MOVQAX, my_string+48(SP)        </span><br><span class="line">MOVQ$11, my_string+56(SP)</span><br><span class="line">MOVQ$0, autotmp_0+64(SP)</span><br><span class="line">MOVQ$0, autotmp_0+72(SP)</span><br><span class="line">LEAQtype·string(SB), AX</span><br><span class="line">MOVQAX, (SP)</span><br><span class="line">LEAQmy_string+48(SP), AX        </span><br><span class="line">MOVQAX, 8(SP)</span><br><span class="line">    &#x2F;&#x2F; 创建一个 interface</span><br><span class="line">    CALLruntime·convT2E(SB)           </span><br><span class="line">MOVQ24(SP), AX</span><br><span class="line">MOVQ16(SP), CX                    </span><br><span class="line">MOVQCX, autotmp_0+64(SP)        </span><br><span class="line">MOVQAX, autotmp_0+72(SP)</span><br><span class="line">LEAQautotmp_0+64(SP), AX        </span><br><span class="line">MOVQAX, (SP)                      </span><br><span class="line">MOVQ$1, 8(SP)                      </span><br><span class="line">MOVQ$1, 16(SP)</span><br><span class="line">    &#x2F;&#x2F; 调用 fmt.Println</span><br><span class="line">    CALLfmt·Println(SB)</span><br><span class="line"></span><br><span class="line">    MOVQ 80(SP), BP</span><br><span class="line">ADDQ $88, SP</span><br><span class="line">RET</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一行的 <code>#include</code> 加载一些常量，这里我们将用到 <code>RODATA</code>. </p><p><code>DATA</code> 用于在内存中存储字符串，一次可以存储 1,2,4或8 字节。在符号后的<code>&lt;&gt;</code>作用是限制数据在当前文件使用。</p><p><code>GLOBL</code> 将数据设为全局，只读，相对位置12.</p><h1 id="Example-gid"><a href="#Example-gid" class="headerlink" title="Example: gid"></a>Example: gid</h1><p>gid 库中用到的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;go_asm.h&quot;</span><br><span class="line">#include &quot;go_tls.h&quot;</span><br><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回值 8 bytes, 符号为 getg</span><br><span class="line">TEXT ·getg(SB), NOSPLIT, $0-8</span><br><span class="line">    &#x2F;&#x2F; get_tls 的宏为： #defineget_tls(r)MOVQ TLS, r</span><br><span class="line">    &#x2F;&#x2F; 等价于 MOVQ TLS, CX</span><br><span class="line">    &#x2F;&#x2F; 从 TLS(Thread Local Storage) 起始移动 8 byte 值 到 CX 寄存器</span><br><span class="line">    get_tls(CX)</span><br><span class="line">    &#x2F;&#x2F; g的宏为： g(r)0(r)(TLS*1)</span><br><span class="line">    &#x2F;&#x2F; 等价于 0(CX)(TLS*1), AX</span><br><span class="line">    &#x2F;&#x2F; 查到意义为 indexed with offset, 这里 offset&#x3D;0, 索引是什么意思不清楚</span><br><span class="line">    MOVQ    g(CX), AX</span><br><span class="line">    &#x2F;&#x2F; 从AX起始移动 8 byte 值，到ret符号的位置</span><br><span class="line">    MOVQ    AX, ret+0(FP)</span><br><span class="line">    RET</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Example-SwapInt32"><a href="#Example-SwapInt32" class="headerlink" title="Example: SwapInt32"></a>Example: SwapInt32</h1><p>一个原子交换 int32 的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> atomic</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="keyword">int32</span>, <span class="built_in">new</span> <span class="keyword">int32</span>)</span> <span class="params">(old <span class="keyword">int32</span>)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;textflag.h&quot;</span><br><span class="line">&#x2F;&#x2F; 参数大小 &#x3D; 8 + 4 + 4 , + 4 (默认的 ret符号?)</span><br><span class="line">TEXT ·SwapInt32(SB),NOSPLIT,$0-20</span><br><span class="line">JMP·SwapUint32(SB)</span><br><span class="line">TEXT ·SwapUint32(SB),NOSPLIT,$0-20</span><br><span class="line">    &#x2F;&#x2F; 第一个参数 移动 8 byte 到 BP</span><br><span class="line">MOVQaddr+0(FP), BP</span><br><span class="line">    &#x2F;&#x2F; 第二个参数 移动 4 byte 到 AX</span><br><span class="line">MOVLnew+8(FP), AX</span><br><span class="line">    &#x2F;&#x2F; 原子操作, write-after-read, 把 (AX, offset&#x3D;0) 与 (BP, offset&#x3D;0) 交换 4 byte 数据</span><br><span class="line">XCHGLAX, 0(BP)</span><br><span class="line">    &#x2F;&#x2F; 移动 AX 到 old 符号</span><br><span class="line">MOVLAX, old+16(FP)</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近升级 go1.9，发现一个获取 goroutine id 的依赖没有支持1.9，于是手动写了一个，顺便学习一下 go assembly。希望你看完这篇文章后，对go汇编有一定的了解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="golang" scheme="http://localhost:4000/categories/tech/golang/"/>
    
    
      <category term="golang" scheme="http://localhost:4000/tags/golang/"/>
    
      <category term="assembly" scheme="http://localhost:4000/tags/assembly/"/>
    
  </entry>
  
  <entry>
    <title>Go语言channel与select原理</title>
    <link href="http://localhost:4000/2017/08/23/channel-and-select/"/>
    <id>http://localhost:4000/2017/08/23/channel-and-select/</id>
    <published>2017-08-23T06:25:34.000Z</published>
    <updated>2019-01-10T06:30:49.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文会尝试解释 go runtime 中 channel 和 select 的具体实现，部分内容来自 gophercon2017。Go版本为1.8.3</p></blockquote><a id="more"></a><h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><p>第一部分讲述一下 channel 的用法。channel 可以看做一个队列，用于多个goroutine之间的通信，例如下面的例子，一个goroutine发送msg，另一个msg接受消息。channel 分为带缓冲和不带缓冲，差别不是很大，具体请自行google。看一个简单的例子，了解一下channel的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a new channel with `make(chan val-type)`.</span></span><br><span class="line">    <span class="comment">// Channels are typed by the values they convey.</span></span><br><span class="line">    messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="comment">// Send a value into a channel using the `channel &lt;-`</span></span><br><span class="line">    <span class="comment">// syntax. Here we send `&quot;ping&quot;`  to the `messages`</span></span><br><span class="line">    <span class="comment">// channel we made above, from a new goroutine.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; messages &lt;- <span class="string">&quot;ping&quot;</span> &#125;()</span><br><span class="line">    <span class="comment">// The `&lt;-channel` syntax receives a value from the</span></span><br><span class="line">    <span class="comment">// channel. Here we&#x27;ll receive the `&quot;ping&quot;` message</span></span><br><span class="line">    <span class="comment">// we sent above and print it out.</span></span><br><span class="line">    msg := &lt;-messages</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel的功能点：</p><ol><li>队列</li><li>阻塞</li><li>当一端阻塞，可以被另一个端唤醒</li></ol><p>我们围绕这3点功能展开，讲讲具体的实现。</p><h2 id="channel结构"><a href="#channel结构" class="headerlink" title="channel结构"></a>channel结构</h2><p>注释标注了几个重要的变量，从功能上大致可以分为两个功能单元，一个是 ring buffer，用于存数据； 一个是存放 goroutine 的队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列中的元素个数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// 缓冲队列的固定大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 缓冲数组</span></span><br><span class="line">elemsize <span class="keyword">uint16</span></span><br><span class="line">closed   <span class="keyword">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// 下一次发送的 index</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// 下一次接收的 index</span></span><br><span class="line">recvq    waitq  <span class="comment">// 接受者队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// 发送者队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ring-Buffer"><a href="#Ring-Buffer" class="headerlink" title="Ring Buffer"></a>Ring Buffer</h2><p>主要是以下变量组成的功能, 一个 buf 存储实际数据，两个指针分别代表发送，接收的索引位置，配合 size, count 在数组大小范围内来回滑动。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// 当前队列中的元素个数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// 缓冲队列的固定大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 缓冲数组</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// 下一次发送的 index</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// 下一次接收的 index</span></span><br></pre></td></tr></table></figure><p>举个例子，假设我们初始化了一个带缓冲的channel, <code>ch := make(chan int, 3)</code>， 那么它初始状态的值为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qcount   = <span class="number">0</span></span><br><span class="line">dataqsiz = <span class="number">3</span></span><br><span class="line">buf      = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>， <span class="number">0</span>， <span class="number">0</span>&#125; <span class="comment">// 表示长度为3的数组</span></span><br><span class="line">sendx    = <span class="number">0</span></span><br><span class="line">recvx    = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>第一步，向 channel 里 send 一个值， <code>ch &lt;- 1</code>, 因为现在缓冲还没满，所以操作后状态如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qcount   = <span class="number">1</span></span><br><span class="line">dataqsiz = <span class="number">3</span></span><br><span class="line">buf      = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>， <span class="number">0</span>， <span class="number">0</span>&#125; <span class="comment">// 表示长度为3的数组</span></span><br><span class="line">sendx    = <span class="number">1</span></span><br><span class="line">recvx    = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>快进两部，连续向 channel 里 send 两个值 (2, 3)，状态如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qcount   = <span class="number">3</span></span><br><span class="line">dataqsiz = <span class="number">3</span></span><br><span class="line">buf      = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125; <span class="comment">// 表示长度为3的数组</span></span><br><span class="line">sendx    = <span class="number">0</span> <span class="comment">// 下一个发送的 index 回到了0</span></span><br><span class="line">recvx    = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从 channel 中 receive 一个值， <code>&lt;- ch</code>, 状态如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qcount   = <span class="number">2</span></span><br><span class="line">dataqsiz = <span class="number">3</span></span><br><span class="line">buf      = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>， <span class="number">2</span>， <span class="number">3</span>&#125; <span class="comment">// 表示长度为3的数组</span></span><br><span class="line">sendx    = <span class="number">0</span> <span class="comment">// 下一个发送的 index 回到了0</span></span><br><span class="line">recvx    = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>我们看下，如果 receive channel 时，channel 的 buffer中没有数据是怎么处理的。逻辑在 <code>chanrecv</code> 这个方法中，它的大致流程如下，仅保留了阻塞操作的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(t *chantype, c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查 channdel 是否为 nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当不阻塞时，检查buffer大小，当前大小，检查chennel是否关闭，看看是否能直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查发送端是否有等待的goroutine，下部分会提到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前buffer中有数据，则尝试取出。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果非阻塞，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有sender等待，buffer中没有数据，则阻塞等待。</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.selectdone = <span class="literal">nil</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">    <span class="comment">//关键操作：设置 goroutine 状态为 waiting, 把 G 和 M 分离</span></span><br><span class="line">goparkunlock(&amp;c.lock, <span class="string">&quot;chan receive&quot;</span>, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up</span></span><br><span class="line">    <span class="comment">// 被唤醒，清理 sudog</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的操作就是 创建一个 当前 goroutine 的 sudog, 然后把这个 sudog 放入 channel 的接受者等待队列；设置当前 G 的状态，和 M分离，到这里当前G就阻塞了，代码不会执行下去。<br>当被唤醒后，执行sudog的清理操作。这里接受buffer中的值的指针是 <code>ep</code> 这个变量，被唤醒后好像没有向 <code>ep</code> 中赋值的操作。这个我们下部分会讲。</p><h2 id="sudog"><a href="#sudog" class="headerlink" title="sudog"></a>sudog</h2><p>还剩最后一个疑问，当一个goroutine因为channel阻塞，另一个goroutine是如何唤醒它的。</p><p>channel 中有两个 <code>waitq</code> 类型的变量, 看下结构发现，就是sudog的链表，关键是 sudog。sudog中包含了goroutine的引用，注意一下 <code>elem</code>这个变量，注释说可能会指向stack。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line"><span class="comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line"><span class="comment">// this.</span></span><br><span class="line">g          *g</span><br><span class="line">selectdone *<span class="keyword">uint32</span> <span class="comment">// CAS to 1 to win select race (may point to stack)</span></span><br><span class="line">next       *sudog</span><br><span class="line">prev       *sudog</span><br><span class="line">elem       unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line"><span class="comment">// waitlink is only accessed by g.</span></span><br><span class="line"></span><br><span class="line">acquiretime <span class="keyword">int64</span></span><br><span class="line">releasetime <span class="keyword">int64</span></span><br><span class="line">ticket      <span class="keyword">uint32</span></span><br><span class="line">waitlink    *sudog <span class="comment">// g.waiting list</span></span><br><span class="line">c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲阻塞部分的时候，我们看到goroutine被调度之前，有一个 <code>enqueue</code>操作，这时，当前G的sudog已经被存入<code>recvq</code>中，我们看下发送者这时的操作。</p><p>这里的操作是，sender发送的值 直接被拷贝到 sudog.elem 了。然后唤醒 sudog.g ，这样对面的receiver goroutine 就被唤醒了。具体请下面的注释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(t *chantype, c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 检查工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果能从 chennel 的 recvq 弹出 sudog, 那么直接send</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line"><span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buffer有空余空间，返回； 阻塞操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 处理 index</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是根据 elemtype.size 复制内存</span></span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设置 goroutine 的状态，唤醒它</span></span><br><span class="line">goready(gp, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src is on our stack, dst is a slot on another stack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Once we read sg.elem out of sg, it will no longer</span></span><br><span class="line"><span class="comment">// be updated if the destination&#x27;s stack gets copied (shrunk).</span></span><br><span class="line"><span class="comment">// So make sure that no preemption points can happen between read &amp; use.</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="keyword">uintptr</span>(dst), <span class="keyword">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// memmove copies n bytes from &quot;from&quot; to &quot;to&quot;.</span></span><br><span class="line"><span class="comment">// in memmove_*.s</span></span><br><span class="line"><span class="comment">//go:noescape</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memmove</span><span class="params">(to, from unsafe.Pointer, n <span class="keyword">uintptr</span>)</span></span></span><br></pre></td></tr></table></figure><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>在看 <code>chanrecv()</code>方法 时，发现了一个 block 参数，代表操作是否阻塞。一般情况下，channel 都是阻塞的（不考虑buffer），那什么时候非阻塞呢？</p><p>第一个想到的就是 select, 在写了default case的时候，其他的channel是非阻塞的。</p><p>还有一个可能不常用，就是 channel 的反射 value, 可以是非阻塞的，这个方法是public的，我们先看下简单的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">TryRecv</span><span class="params">()</span> <span class="params">(x Value, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">TrySend</span><span class="params">(x Value)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>select 就复杂一点点，首先在源码中发现一段注释:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//select &#123;</span></span><br><span class="line"><span class="comment">//case c &lt;- v:</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(t *chantype, c *hchan, elem unsafe.Pointer)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(t, c, elem, <span class="literal">false</span>, getcallerpc(unsafe.Pointer(&amp;t)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//select &#123;</span></span><br><span class="line"><span class="comment">//case v = &lt;-c:</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if selectnbrecv(&amp;v, c) &#123;</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(t *chantype, elem unsafe.Pointer, c *hchan)</span> <span class="params">(selected <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">selected, _ = chanrecv(t, c, elem, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是一个 case + default 的模式，那么编译器就调用以上方法来实现。</p><p>如果是多个 case + default 的模式呢？select 在runtime到底是如何执行的？写个简单的select编译一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">case</span> ch &lt;- <span class="number">1</span>:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>go tool compile -S -l -N test.go &gt; test.s</code> 结果中找一下关键字，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x008c 00140 (test.go:5)CALLruntime.newselect(SB)</span><br><span class="line">0x00ad 00173 (test.go:6)CALLruntime.selectrecv(SB)</span><br><span class="line">0x00ec 00236 (test.go:7)CALLruntime.selectsend(SB)</span><br><span class="line">0x0107 00263 (test.go:8)CALLruntime.selectdefault(SB)</span><br><span class="line">0x0122 00290 (test.go:5)CALLruntime.selectgo(SB)</span><br></pre></td></tr></table></figure><p>这里 <code>selectgo</code> 是实际运行的方法，找一下，注意注释。先检查channel是否能操作，如果不能操作，就走 default 逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line"><span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line"><span class="keyword">var</span> dfl *scase</span><br><span class="line"><span class="keyword">var</span> cas *scase</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(sel.ncase); i++ &#123;</span><br><span class="line">cas = &amp;scases[pollorder[i]]</span><br><span class="line">c = cas.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">        <span class="comment">// 接受数据</span></span><br><span class="line"><span class="keyword">case</span> caseRecv:</span><br><span class="line">sg = c.sendq.dequeue()</span><br><span class="line">            <span class="comment">// 如果有 sender 在等待</span></span><br><span class="line"><span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> recv</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 当前buffer中有数据</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> bufrecv</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 关闭的channel</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> rclose</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> caseSend:</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(unsafe.Pointer(c), cas.pc, chansendpc)</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 关闭</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> sclose</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 有 receiver 正在等待</span></span><br><span class="line">sg = c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> send</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 有空间接受</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="keyword">goto</span> bufsend</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 走default</span></span><br><span class="line"><span class="keyword">case</span> caseDefault:</span><br><span class="line">dfl = cas</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line">cas = dfl</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文会尝试解释 go runtime 中 channel 和 select 的具体实现，部分内容来自 gophercon2017。Go版本为1.8.3&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="golang" scheme="http://localhost:4000/categories/tech/golang/"/>
    
    
      <category term="golang" scheme="http://localhost:4000/tags/golang/"/>
    
      <category term="channel" scheme="http://localhost:4000/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Golang 与系统调用</title>
    <link href="http://localhost:4000/2017/08/12/golang-and-syscalls/"/>
    <id>http://localhost:4000/2017/08/12/golang-and-syscalls/</id>
    <published>2017-08-12T09:04:37.000Z</published>
    <updated>2019-01-10T06:30:49.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GopherCon2017 中的一个视频讲解了如何用golang实现一个简单的strace，本文是基于此演讲整理而来。</p></blockquote><a id="more"></a><h2 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h2><p>先看下wiki的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In computing, a system call is the programmatic way in which a computer program requests a service from the kernel of the operating system it is executed on. This may include hardware-related services (for example, accessing a hard disk drive), creation and execution of new processes, and communication with integral kernel services such as process scheduling. System calls provide an essential interface between a process and the operating system.</span><br></pre></td></tr></table></figure><p>系统调用是程序向操作系统内核请求服务的过程，通常包含硬件相关的服务，例如访问硬盘，创建新进程。系统调用提供了一个进程和操作系统之间的接口。</p><h3 id="syscall无处不在"><a href="#syscall无处不在" class="headerlink" title="syscall无处不在"></a>syscall无处不在</h3><p>只要在os上写程序，就无法避免和syscall打交道。举个最常用的例子, <code>fmt.Println(&quot;hello world&quot;)</code>, 这里就用到了系统调用  <code>write</code>, 我们翻一下源码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrintln(a)</span><br><span class="line">    <span class="comment">// writer 是 stdout</span></span><br><span class="line">n, err = w.Write(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stdout = NewFile(<span class="keyword">uintptr</span>(syscall.Stdout), <span class="string">&quot;/dev/stdout&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(b) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 实际的write方法，就是调用syscall.Write()</span></span><br><span class="line"><span class="keyword">return</span> fixCount(syscall.Write(f.fd, b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Zero-Copy"><a href="#Zero-Copy" class="headerlink" title="Zero-Copy"></a>Zero-Copy</h3><p>再举一个例子，我们常听到的 zero-copy，我们看看zero-copy是用来解决什么问题的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>借用一张图来说明问题<br><img src="/resource/image/read-write-syscall.jpg" alt="img"></p><ol><li>第一步，<code>read()</code>导致上下文切换(context switch)，从用户模式进入内核模式，DMA(Direct memory access) engine 从磁盘中读取内容，存入内核地址buffer。</li><li>第二步，数据从内核buffer拷贝入用户buffer，<code>read()</code>返回，上下文切换回用户态。</li><li>第三步，<code>write()</code>上下文切换，把buffer拷贝到内核地址buffer。</li><li>第四步，<code>write()</code>返回，第四次上下文切换，DMA engine 把数据从内核buffer传给协议引擎，一般是进入队列，等待传输。</li></ol><p>我们看到，这里数据在用户空间和内核空间来回拷贝，其实是不必要的。</p><p>解决的办法有: <code>mmap</code>, <code>sendfile</code>, 具体可以参考这篇<a href="http://www.linuxjournal.com/article/6345?page=0,0">文章</a></p><p>到这里我们应该对系统调用有了一定的认识了。</p><h2 id="Strace"><a href="#Strace" class="headerlink" title="Strace"></a>Strace</h2><p><code>strace</code> 是用于查看进程系统调用的工具, 一般使用方法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">strace &lt;bin&gt;</span><br><span class="line">strace -p &lt;pid&gt;</span><br><span class="line">// 用于统计各个系统调用的次数</span><br><span class="line">strace -c &lt;bin&gt;</span><br><span class="line"></span><br><span class="line">// 例如</span><br><span class="line">strace -c echo hello</span><br><span class="line">hello</span><br><span class="line"><span class="meta">%</span><span class="bash"> time     seconds  usecs/call     calls    errors syscall</span></span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">  0.00    0.000000           0         1           read</span><br><span class="line">  0.00    0.000000           0         1           write</span><br><span class="line">  0.00    0.000000           0         3           open</span><br><span class="line">  0.00    0.000000           0         5           close</span><br><span class="line">  0.00    0.000000           0         4           fstat</span><br><span class="line">  0.00    0.000000           0         7           mmap</span><br><span class="line">  0.00    0.000000           0         4           mprotect</span><br><span class="line">  0.00    0.000000           0         1           munmap</span><br><span class="line">  0.00    0.000000           0         3           brk</span><br><span class="line">  0.00    0.000000           0         3         3 access</span><br><span class="line">  0.00    0.000000           0         1           execve</span><br><span class="line">  0.00    0.000000           0         1           arch_prctl</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    0.000000                    34         3 total</span><br></pre></td></tr></table></figure><p>stace 的实现原理是系统调用 ptrace, 我们来看下 ptrace 是什么。</p><h2 id="Ptrace"><a href="#Ptrace" class="headerlink" title="Ptrace"></a>Ptrace</h2><p>man page 描述如下：</p><p>The ptrace() system call provides a means by which one process (the “tracer”) may <em>observe</em> and <em>control</em> the execution of another process (the “tracee”), and examine and change the tracee’s memory and registers.  It is primarily used to implement breakpoint debuggingand system call tracing.</p><p>简单来说有三大能力:</p><ul><li>追踪系统调用</li><li>读写内存和寄存器</li><li>向被追踪程序传递信号</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">int</span> request, <span class="keyword">pid_t</span> pid, <span class="keyword">caddr_t</span> addr, <span class="keyword">int</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line">request包含:</span><br><span class="line">PTRACE_ATTACH</span><br><span class="line">PTRACE_SYSCALL</span><br><span class="line">PTRACE_PEEKTEXT, PTRACE_PEEKDATA</span><br><span class="line">等</span><br></pre></td></tr></table></figure><p>tracer 使用 <code>PTRACE_ATTACH</code> 命令，指定需要追踪的PID。紧接着调用 <code>PTRACE_SYSCALL</code>。<br>tracee 会一直运行，直到遇到系统调用，内核会停止执行。 此时，tracer 会收到 <code>SIGTRAP</code> 信号，tracer 就可以打印内存和寄存器中的信息了。</p><p>接着，tracer 继续调用 <code>PTRACE_SYSCALL</code>, tracee 继续执行，直到 tracee退出当前的系统调用。<br>需要注意的是，这里在进入syscall和退出syscall时，tracer都会察觉。</p><h2 id="myStrace"><a href="#myStrace" class="headerlink" title="myStrace"></a>myStrace</h2><p>了解以上内容后，presenter 现场实现了一个go版本的strace, 需要在 linux amd64 环境编译。<br><a href="https://github.com/silentred/gosys">github</a></p><p>// strace.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> regs syscall.PtraceRegs</span><br><span class="line"><span class="keyword">var</span> ss syscallCounter</span><br><span class="line">ss = ss.init()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Run: &quot;</span>, os.Args[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(os.Args[<span class="number">1</span>], os.Args[<span class="number">2</span>:]...)</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">Ptrace: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd.Start()</span><br><span class="line">err = cmd.Wait()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Wait err %v \n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid := cmd.Process.Pid</span><br><span class="line">exit := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 记得 PTRACE_SYSCALL 会在进入和退出syscall时使 tracee 暂停，所以这里用一个变量控制，RAX的内容只打印一遍</span></span><br><span class="line"><span class="keyword">if</span> exit &#123;</span><br><span class="line">err = syscall.PtraceGetRegs(pid, &amp;regs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Printf(&quot;%#v \n&quot;,regs)</span></span><br><span class="line">name := ss.getName(regs.Orig_rax)</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %s, id: %d \n&quot;</span>, name, regs.Orig_rax)</span><br><span class="line">ss.inc(regs.Orig_rax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = syscall.PtraceSyscall(pid, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = syscall.Wait4(pid, <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit = !exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ss.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 用于统计信息的counter, syscallcounter.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;text/tabwriter&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/seccomp/libseccomp-golang&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> syscallCounter []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxSyscalls = <span class="number">303</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s syscallCounter)</span> <span class="title">init</span><span class="params">()</span> <span class="title">syscallCounter</span></span> &#123;</span><br><span class="line">s = <span class="built_in">make</span>(syscallCounter, maxSyscalls)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s syscallCounter)</span> <span class="title">inc</span><span class="params">(syscallID <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> syscallID &gt; maxSyscalls &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid syscall ID (%x)&quot;</span>, syscallID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s[syscallID]++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s syscallCounter)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">w := tabwriter.NewWriter(os.Stdout, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="string">&#x27; &#x27;</span>, tabwriter.AlignRight|tabwriter.Debug)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">name, _ := seccomp.ScmpSyscall(k).GetName()</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%d\t%s\n&quot;</span>, v, name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s syscallCounter)</span> <span class="title">getName</span><span class="params">(syscallID <span class="keyword">uint64</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">name, _ := seccomp.ScmpSyscall(syscallID).GetName()</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Run:  [echo hello]</span><br><span class="line">Wait err stop signal: trace&#x2F;breakpoint trap</span><br><span class="line">name: execve, id: 59</span><br><span class="line">name: brk, id: 12</span><br><span class="line">name: access, id: 21</span><br><span class="line">name: mmap, id: 9</span><br><span class="line">name: access, id: 21</span><br><span class="line">name: open, id: 2</span><br><span class="line">name: fstat, id: 5</span><br><span class="line">name: mmap, id: 9</span><br><span class="line">name: close, id: 3</span><br><span class="line">name: access, id: 21</span><br><span class="line">name: open, id: 2</span><br><span class="line">name: read, id: 0</span><br><span class="line">name: fstat, id: 5</span><br><span class="line">name: mmap, id: 9</span><br><span class="line">name: mprotect, id: 10</span><br><span class="line">name: mmap, id: 9</span><br><span class="line">name: mmap, id: 9</span><br><span class="line">name: close, id: 3</span><br><span class="line">name: mmap, id: 9</span><br><span class="line">name: arch_prctl, id: 158</span><br><span class="line">name: mprotect, id: 10</span><br><span class="line">name: mprotect, id: 10</span><br><span class="line">name: mprotect, id: 10</span><br><span class="line">name: munmap, id: 11</span><br><span class="line">name: brk, id: 12</span><br><span class="line">name: brk, id: 12</span><br><span class="line">name: open, id: 2</span><br><span class="line">name: fstat, id: 5</span><br><span class="line">name: mmap, id: 9</span><br><span class="line">name: close, id: 3</span><br><span class="line">name: fstat, id: 5</span><br><span class="line">hello</span><br><span class="line">name: write, id: 1</span><br><span class="line">name: close, id: 3</span><br><span class="line">name: close, id: 3</span><br><span class="line">        1|read</span><br><span class="line">        1|write</span><br><span class="line">        3|open</span><br><span class="line">        5|close</span><br><span class="line">        4|fstat</span><br><span class="line">        7|mmap</span><br><span class="line">        4|mprotect</span><br><span class="line">        1|munmap</span><br><span class="line">        3|brk</span><br><span class="line">        3|access</span><br><span class="line">        1|execve</span><br><span class="line">        1|arch_prctl</span><br></pre></td></tr></table></figure><p>对比一下结果，可以发现和 strace 是一样的。</p><p><a href="https://github.com/lizrice/strace-from-scratch">presenter github</a><br><a href="https://www.youtube.com/watch?v=01w7viEZzXQ&t=1221s">youtube视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;GopherCon2017 中的一个视频讲解了如何用golang实现一个简单的strace，本文是基于此演讲整理而来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="golang" scheme="http://localhost:4000/categories/tech/golang/"/>
    
    
      <category term="golang" scheme="http://localhost:4000/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 多列索引</title>
    <link href="http://localhost:4000/2017/08/12/mysql-multi-col-index/"/>
    <id>http://localhost:4000/2017/08/12/mysql-multi-col-index/</id>
    <published>2017-08-12T07:47:05.000Z</published>
    <updated>2019-01-10T06:30:49.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说说 mysql 联合索引， 解读 mysql 文档， 看看什么时候会利用 联合索引，什么时候 mysql server 不使用。</p></blockquote><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test (</span><br><span class="line">    id         INT NOT NULL,</span><br><span class="line">    last_name  CHAR(30) NOT NULL,</span><br><span class="line">    first_name CHAR(30) NOT NULL,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX name (last_name,first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="会利用索引的查询"><a href="#会利用索引的查询" class="headerlink" title="会利用索引的查询"></a>会利用索引的查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; last_name 是索引最左字段，所以可以利用</span><br><span class="line">SELECT * FROM test WHERE last_name&#x3D;&#39;Widenius&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 两个AND等值查询，可以利用</span><br><span class="line">SELECT * FROM test</span><br><span class="line">  WHERE last_name&#x3D;&#39;Widenius&#39; AND first_name&#x3D;&#39;Michael&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 和上面等价，sql优化器会处理顺序问题</span><br><span class="line">SELECT * FROM test</span><br><span class="line">  WHERE first_name&#x3D;&#39;Michael&#39; AND last_name&#x3D;&#39;Widenius&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; first_name 可以是等值OR, 或者 范围条件</span><br><span class="line">SELECT * FROM test</span><br><span class="line">  WHERE last_name&#x3D;&#39;Widenius&#39;</span><br><span class="line">  AND (first_name&#x3D;&#39;Michael&#39; OR first_name&#x3D;&#39;Monty&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM test</span><br><span class="line">  WHERE last_name&#x3D;&#39;Widenius&#39;</span><br><span class="line">  AND first_name &gt;&#x3D;&#39;M&#39; AND first_name &lt; &#39;N&#39;;</span><br></pre></td></tr></table></figure><h3 id="不会利用联合索引"><a href="#不会利用联合索引" class="headerlink" title="不会利用联合索引"></a>不会利用联合索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 条件中没有包含最左字段 last_name</span><br><span class="line">SELECT * FROM test WHERE first_name&#x3D;&#39;Michael&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 个人认为， last_name 的条件会用到索引，因为最左原则；</span><br><span class="line">&#x2F;&#x2F; 最后和另一个条件合并结果</span><br><span class="line">SELECT * FROM test</span><br><span class="line">  WHERE last_name&#x3D;&#39;Widenius&#39; OR first_name&#x3D;&#39;Michael&#39;;</span><br></pre></td></tr></table></figure><h3 id="Index-Merge-Optimization"><a href="#Index-Merge-Optimization" class="headerlink" title="Index Merge Optimization"></a>Index Merge Optimization</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE col1&#x3D;val1 AND col2&#x3D;val2;</span><br></pre></td></tr></table></figure><p>对于这类的请求，如果有 multiple-column index, 则直接使用此索引。如果有单独索引 col1 或者 col2, 那么优化器尝试 Index Merge optimization, 或者尝试找到限制最多的索引(排除的行数最多，这样效率较高)。</p><p>Index Merge 是指，对于多个范围扫描，把合并结果。合并结果的类型可以是 并集，交集，等。索引不能跨表。<br>以下例子可能会利用 Index Merge.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; key1, key2 有单独索引, 分别利用索引，结果合并</span><br><span class="line">SELECT * FROM tbl_name WHERE key1 &#x3D; 10 OR key2 &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 和上面一样, 得到合集后，扫描合集筛选 non-key 字段</span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1 &#x3D; 10 OR key2 &#x3D; 20) AND non_key &#x3D; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 时利用两个索引scan，取交集</span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE (key1_part1 &#x3D; 1 AND key1_part2 &#x3D; 2) AND key2 &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同上，主键可以是范围查询</span><br><span class="line">SELECT * FROM innodb_table</span><br><span class="line">  WHERE primary_key &lt; 10 AND key_col1 &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取并集</span><br><span class="line">SELECT * FROM t1</span><br><span class="line">  WHERE key1 &#x3D; 1 OR key2 &#x3D; 2 OR key3 &#x3D; 3;</span><br></pre></td></tr></table></figure><h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>假设有 (col1, col2, col3) 联合索引，最左前缀为 col1, 不包含col1条件的查询，不会使用此联合索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 会使用</span><br><span class="line">SELECT * FROM tbl_name WHERE col1&#x3D;val1;</span><br><span class="line">SELECT * FROM tbl_name WHERE col1&#x3D;val1 AND col2&#x3D;val2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不会使用</span><br><span class="line">SELECT * FROM tbl_name WHERE col2&#x3D;val2;</span><br><span class="line">SELECT * FROM tbl_name WHERE col2&#x3D;val2 AND col3&#x3D;val3;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;说说 mysql 联合索引， 解读 mysql 文档， 看看什么时候会利用 联合索引，什么时候 mysql server 不使用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="mysql" scheme="http://localhost:4000/categories/tech/mysql/"/>
    
    
      <category term="mysql" scheme="http://localhost:4000/tags/mysql/"/>
    
      <category term="index" scheme="http://localhost:4000/tags/index/"/>
    
  </entry>
  
  <entry>
    <title>关于程序员之道</title>
    <link href="http://localhost:4000/2017/07/30/choose-the-right-way/"/>
    <id>http://localhost:4000/2017/07/30/choose-the-right-way/</id>
    <published>2017-07-30T06:33:49.000Z</published>
    <updated>2019-01-10T06:30:49.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近和一些前辈聊了一些东西，让我意识到了自己的一些问题，虽然自己之前也有一些类似的疑惑和思考，但是并没有人明确指出问题。最近的几次谈话让我不得不仔细思考这些问题，边写边思考，看看能走到哪一步。</p></blockquote><a id="more"></a><h2 id="耗子叔的分享"><a href="#耗子叔的分享" class="headerlink" title="耗子叔的分享"></a>耗子叔的分享</h2><p>前一阵子耗子叔来我司分享，说到了他的一个观点: 人对一个事情的兴趣是会随着不断重复这件事而消耗的，一件好玩的事，你的兴趣再浓厚，每天重复，总有一天会觉得无聊，假如这件事正好是你的工作，那一旦失去兴趣，你的日子就会变得非常难过。他举了个例子，假设一个程序员他一辈子想写的代码就100w行，超过这个数他就厌倦了，写一行少一行，那么他应该让他的每一行代码发挥在价值最大的地方。他又举了个例子，说他帮别人外包解决系统性能问题，外包架构设计，报酬丰厚。</p><p>我觉得这里最重要的点就是”价值最大的地方”，如何衡量价值最大？在A公司薪资1w，在B公司薪资2w，B公司就是价值大的地方吗？这是在鼓励程序员跳槽吗？我觉得不全对，这样理解是片面的。</p><h2 id="和前同事的交流"><a href="#和前同事的交流" class="headerlink" title="和前同事的交流"></a>和前同事的交流</h2><p>之前和以为同事在他离职前聊了一下，关于个人发展的一些话题。大概涉及到了，对自己能力的评估，比如算法，数据结构，想做什么样的事，竞争力如何等等。我对自己的评价是这样的，智力只能算中等水平，因为数学不是我的强项; 逻辑能力，理解能力还不错，高中，大学物理特别好，就是因为物理并不需要特别强的数学能力，理解公式的含义就能解题; 英文能力不错，阅读和口语都不错，特别是技术相关的话题，学校里的基础就不错，这些年看文档和技术文章得到不少锻炼，自认为在程序员中英文能力算是不错的。算法和数据结构不是我的强项，能力范围是根据现有理论能实现算法，可能无法创造出一个算法，或者说反应比较慢，通常要想的比较久。操作系统，计算机原理呢，这些都是自学的，了解一些内容，难免有半吊子的嫌疑。</p><p>这是自身的现有条件，这样的一个我，适合去深入一方面呢？或者说在哪个领域和别人竞争呢？</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>其实过去也有想过一个问题，自己看的东西很多，但是深入到非常底层的点却几乎没有。要说非常深入的话，要算Laravel这个框架，源码几乎都读过。因为工作用用到了，所以想学透它。但是最近半年都没用了，所以对新的代码不熟悉。</p><p>这种现状的原因是什么呢？</p><h2 id="程序员需要什么能力"><a href="#程序员需要什么能力" class="headerlink" title="程序员需要什么能力"></a>程序员需要什么能力</h2><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>Linus 采访说一个成功的项目是99%的努力+1%的创新，他之前甚至说过所谓的技术创新都是扯淡。大部分程序员都是为了实现业务服务的，这部分程序员比拼的是抽象业务的能力，对业务模型抽象的好，设计出来的系统简单易懂，开发也快速，比如，同一个业务，一个程序员设计了2张表就完成了功能，并且考虑了一定的扩展性，而另一个程序员设计了5张表，没有扩展性，这就是差别。据我观察，抽象能力好的程序员不是很多。</p><p>做业务的程序员如果能对常用工具的原理有一些探究，例如看看框架的实现，看看数据库的源码，能修修改改一些东西，那就更加有竞争力了。这样的人比较少了，基本都是是对计算机有浓厚兴趣，好奇心的人，在业余时间会去钻研的人。我也面试过一些大厂出来的程序员，很少有能到达这个水平的，也可能是我面的人都比较水。</p><p>这里漏说了一个程序员的基本技能，就是写代码。写代码分为三个层级:</p><ul><li>代码可读。表现为，变量命名，函数命名，数据结构命名，语义是否明确；代码注释是否可读。这是最基本的要求，所以英语对程序员非常重要。做到需要少量思考。</li><li>代码可重用。表现为，是否有重复的控制(control)出现，逻辑相类似的代码是否提炼出来公用的方法。是否运用设计模式。做到需要稍微多一些的思考，主要还是抽象能力。</li><li>代码可测试。表现为，单元测试的覆盖率。这个指标非常明确，覆盖率越高越好。可测试代表了你对数据结构的依赖做了比较好的规划，一般会用到面向接口编程。这个需要不少思考，还有工程的能力。</li></ul><p>以上这些我认为我都做到了。</p><p>这些能力就够了吗？No.</p><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>做到以上这些，只是个好的coder，不用愁找不到工作。但是实际的职场并没有那么简单。</p><p>最常用的一个能力就是沟通能力。最近也在反思这些问题，例如，我最头痛的问题就是，和一个人解释问题，但是他怎么也不明白，通常这种情况，我只有耐心说一遍，不得不说第二遍时候我的语气会有变化，我自己也能发现。这样的效果不好，一旦让别人产生敌对情绪，那么你的方案再好，人家也会一意孤行，最终是系统设计烂，整个项目受到牵连。你说沟通能力重不重要。<br>我很讨厌不断重复一件事情，有时候不得不到领导那里仲裁的时候，我描述问题会简略一些，就是因为性格中的那一点问题作怪，导致我的立场没有表达清楚。这点要改。</p><p>如何让别人听你的？这个问题我也回答不好。增强自身的影响力是个办法，如何加强影响力呢？本职工作优秀，乐于帮助别人解决问题，我觉得我能做到这两点，其他的方法还要探索。</p><p>证明自己，影响别人，找到价值，这是我未来3年的大目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近和一些前辈聊了一些东西，让我意识到了自己的一些问题，虽然自己之前也有一些类似的疑惑和思考，但是并没有人明确指出问题。最近的几次谈话让我不得不仔细思考这些问题，边写边思考，看看能走到哪一步。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://localhost:4000/categories/life/"/>
    
      <category term="thinking" scheme="http://localhost:4000/categories/life/thinking/"/>
    
    
      <category term="life" scheme="http://localhost:4000/tags/life/"/>
    
      <category term="programming" scheme="http://localhost:4000/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Java AOP, Annotation 笔记</title>
    <link href="http://localhost:4000/2017/07/22/java-aop-annotation/"/>
    <id>http://localhost:4000/2017/07/22/java-aop-annotation/</id>
    <published>2017-07-22T06:26:02.000Z</published>
    <updated>2019-01-10T06:30:49.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近想看下 RocketMQ, 就打算把 Java 的语法先复习一下，大约4年前写过一些 java，时间久了有些遗忘，而且当时有些东西没搞懂就用了，现在正好补一下这个坑。</p></blockquote><a id="more"></a><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>想学语言最好的方法就是先写他几句，切入点选择了 Spring Boot。没有太多比较，只是因为 Spring 鼎鼎大名。<br>启动很简单，IDE帮忙做了很多事情，但是也有些不爽，只能猜测背后发生的事，具体的命令就不清楚了。</p><p>根据文档，建一个web app很容易，但是搞清楚启动流程就没那么简单了。这些个 Annotation 完全不知道具体作用是什么。<br>于是先找 Annotation 资料。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(<span class="keyword">final</span> ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommandLineRunner()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Let&#x27;s inspect the beans provided by Spring Boot:&quot;</span>);</span><br><span class="line"></span><br><span class="line">                String[] beanNames = ctx.getBeanDefinitionNames();</span><br><span class="line">                Arrays.sort(beanNames);</span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    System.out.println(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><p>找了一些资料，说说我的理解.</p><p>注解就是一种额外的属性，metadata, 是什么的元信息呢？可以是各种，例如 package, class, method, field, parametor等。既然是元信息，那么如果没有人使用它，它就没有任何作用，这点和 Golang 中的 tag类似，但是 tag只能修饰 struct field，作用范围没有java这么广。</p><p>我们来自定义一个注解。所有的注解都是 extends <code>java.lang.annotation.Annotation</code> 的 child interface. 在 annotaion 包里面，给Annotation定义了一些枚举属性，来定义 Annotation 的属性，也就是 定义注解属性的注解。有这么几种:</p><ol><li><code>@Documented</code>: 注解是否包含在JavaDoc中一个简单的标记注解，标识是否将注解信息添加在java文档中</li><li><code>@Retention</code>: 什么时候使用该注解定义该注解的生命周期<ul><li><code>RetentionPolicy.SOURCE</code> 表示在编译阶段丢弃，这些注解在编译结束之后就没意义了，所以它们不会写入字节码.</li><li><code>RetentionPolicy.CLASS</code> 表示在类加载的时候丢弃，在字节码文件的处理中有用，注解默认都使用这种方式</li><li><code>RetentionPolicy.RUNTIME</code> 表示始终不对丢弃，运行期也保留该注释，因此可以使用反射机制读取该注解的信息。</li></ul></li><li><code>@Target</code>: 注解应用于什么地方如果不明确指出，则改注解可以放在任何地方。<ul><li><code>ElementType.TYPE</code> :用于描述类、接口或enum声明</li><li><code>ElementType.FIELD</code> :用于描述实例变量</li><li><code>ElementType.METHOD</code> ：给方法注解</li><li><code>ElementType.PARAMETER</code>：给参数注解</li><li><code>ElementType.CONSTRUCTOR</code> ：给构造方法注解</li><li><code>ElementType.LOCAL_VARIABLE</code> ：给局部变量注解</li><li><code>ElementType.ANNOTATION_TYPE</code> :给注解注解</li><li><code>ElementType.PACKAGE</code> :用于记录java文件的package信息需要说明的是</li></ul></li><li><code>@Inherited</code>: 是否允许子类继承此注解</li><li><code>@Repeatable</code>: 表示他标记的注解是repeatable的，不太理解。</li></ol><p>我们来自定义个 Annotation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Count &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Count(count = 3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = Application.class.getAnnotation(Count.class).count();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Count = %d&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 有 ClassLoader 这个上帝，运行时能拿到所有类的信息，包括注解，所以能通过检查注解做初始化工作。通常一个配置文件就能搞定所有初始化。<br>Golang就做不到，因为没办法通过name找到对应类型，只能通过反射对象得到类型，IoC 不如 java彻底。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>面向切面是一个实用的设计模式，作用是在一个method前后插入一些代码逻辑，这些逻辑一般是复用需求非常大的。<br>实现方法是动态代理，查了一些资料，说说我的看法。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>最原始的方式就是利用 JDK 提供的 <code>InvocationHandler</code> 和 <code>Proxy</code>，拼字符串生成新的代理类源码 .java 文件，然后动态编译，用到了 <code>javax.tools.JavaCompiler</code>·等工具。<br>看了一个别人的例子，感觉非常丑陋。</p><h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>AspectJ 解决了拼字符串的痛苦，自己定义了一种 DSL， 并且提供了编译工具，生成.java源码。猜测本质还是利用了 JDK的提供的接口。这两种都是编译期间AOP实现。</p><h3 id="cglib"><a href="#cglib" class="headerlink" title="cglib"></a>cglib</h3><p>cglib 通过修改字节码实现AOP，是运行时的AOP，所以效率稍差，好处是不用写难看的代码，不用引入aspectj的第三方编译器。现在硬件很便宜，这些性能损耗几乎可以忽略。</p><h3 id="One-for-all-Spring-AOP"><a href="#One-for-all-Spring-AOP" class="headerlink" title="One for all: Spring AOP"></a>One for all: Spring AOP</h3><p>Spring AOP 为 AspectJ 和 cglib 封装了统一的接口，对开发完全透明，具体实现由Spring决定。例如，针对接口的AOP，Spring选择使用JDK，针对 concrete class 的AOP，选择 cglib。（这个结论不确定）</p><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>最近对语言类型一些思考:</p><ul><li>动态弱类型：PHP</li><li>动态强类型：Python</li><li>静态强类型: Go, Java</li><li>貌似没有静态弱类型</li></ul><p>Java选择字节码中间状态，带来了一些动态效果，兼具灵活和稳健，Go就相对没那么灵活。所以Java玩出花的东西，Go就不支持，但是这些花活有一定的学习成本，菜鸟容易掉坑里.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近想看下 RocketMQ, 就打算把 Java 的语法先复习一下，大约4年前写过一些 java，时间久了有些遗忘，而且当时有些东西没搞懂就用了，现在正好补一下这个坑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="java" scheme="http://localhost:4000/categories/tech/java/"/>
    
    
      <category term="java" scheme="http://localhost:4000/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="http://localhost:4000/2017/07/20/what-should-i-say/"/>
    <id>http://localhost:4000/2017/07/20/what-should-i-say/</id>
    <published>2017-07-20T13:36:58.000Z</published>
    <updated>2020-11-02T02:38:10.105Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近心情不太好，正好搭好了这个博客，可以在这里吐槽一下。应该没人知道我是谁，知道也无所谓，大概。偶尔不写技术文章，发发牢骚也挺好的。</p></blockquote><a id="more"></a><h2 id="翻墙-amp-听歌"><a href="#翻墙-amp-听歌" class="headerlink" title="翻墙&amp;听歌"></a>翻墙&amp;听歌</h2><p>最近微博上一个消息闹开了，有人表示<code>北邮</code>研究出了主动探测 shadowsocks 的技术，GFW可以探测ss服务ip，遂封锁此ip。这还不算，twitter上还有人表示为此被请喝茶，还写下保证书不再翻墙。</p><p>我google了下，还真有人分析了下 shadowsocks 的协议漏洞，只要256次测试就可以判断该服务是否为ss。</p><p>解决办法：我想了下，貌似只能修改协议了。问题也很明显，改的地方很多，server端还好说，问题在client端，我是装在路由器上的，这个平台上，编译工具能不能全部安装好还是个疑问，想编译 shadowsocks-libev 这个版本有点难。还有一个 work-around 的就是修改 go 版本的ss，可以绕过编译的问题。</p><p>最近在youtube上看到了 <code>谁是大歌神</code> 这个节目，被林俊杰的表演迷住了。记得小学时候就买了JJ的第一张专辑，那个时候听歌的渠道还是收音机，每晚电台里会放一些新歌，听到林俊杰的歌就知道这人太强了。第一张专辑非常棒，每一首都很好听。之后到了初中，高中，喜欢JJ的人多了起来，我反而没那么喜欢了，不知道为什么。节目中还看到了金莎，感觉成熟了很多，声音还是很好听，和JJ这对CP太完美了，在一起多好啊。</p><p>今晚拿出吉他，唱了一会江南。发现这把电吉他真是买错了，应该买24品的，现在品位不够，弹solo不趁手，扫和弦音色不如民谣，哎，一时冲动，当时买木箱就好了。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>入职新公司有一段时间了，发现一些问题，产品做得不错，技术真是不敢恭维。开始还想着能不能改变，后来发现，不是我想改就能改的，有些东西已经在那里，唯一的办法就是推倒重来。但是这显然不可能，就像上次耗子叔说的，你积极重构的结果是领导说你不出活，领导不知道你是在填别人的坑，他也不在乎，最后的结果就是，放弃填坑，接着挖坑，最后一个接手的人玩不下去。所以关键是要有个懂行的人领导，有权利拍板重构，当然代价是几个月迭代速度巨慢，几乎为0，好处也是显而易见的，未来的开发是站在巨人肩膀上的，需要写的东西越来越少，大大加快开发进度。</p><p>这周得知一个同事要离职了，我觉得和这个有一些关系。已经预见要玩不下去了。当然我有点夸张了，短时间内还能玩，没那么快。</p><p>最近在看 RocketMQ 的一些实现细节，下次写一篇这个吧，阿里的MQ还是很不错的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近心情不太好，正好搭好了这个博客，可以在这里吐槽一下。应该没人知道我是谁，知道也无所谓，大概。偶尔不写技术文章，发发牢骚也挺好的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://localhost:4000/categories/life/"/>
    
      <category term="murmur" scheme="http://localhost:4000/categories/life/murmur/"/>
    
    
      <category term="life" scheme="http://localhost:4000/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>基于 Kubernetes 的微服务治理</title>
    <link href="http://localhost:4000/2017/07/19/microservice-in-kubernetes/"/>
    <id>http://localhost:4000/2017/07/19/microservice-in-kubernetes/</id>
    <published>2017-07-19T08:04:08.000Z</published>
    <updated>2019-01-10T06:30:49.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何使用 kubernetes 部署微服务，包括 服务发现，监控，路由，日志。用实际的例子来演示自动化流程。主要分为以下几个部分:</p><ol><li>5分钟搭建 K8S 集群</li><li>部署 CNI 网络</li><li>部署监控服务</li><li>部署网关</li><li>部署日志服务</li><li>部署一个应用</li></ol><a id="more"></a><h2 id="5分钟搭建-K8S-集群"><a href="#5分钟搭建-K8S-集群" class="headerlink" title="5分钟搭建 K8S 集群"></a>5分钟搭建 K8S 集群</h2><p>第一次完全手动搭建集群大约花了一周时间，主要的问题是在于  </p><ol><li>K8S的组件多，每个程序的参数有不少，哪些是关键的参数需要花时间搞清楚。</li><li>万恶的墙，代理访问外网比较慢</li><li>CNI网络问题，主要是 CNI 网段和云上的局域网网段冲突了，基础知识缺失导致</li><li>K8S 的证书和验证方式不清楚</li></ol><p>本文相关代码位于<a href="https://github.com/silentred/k8s-tut">github</a>, 欢迎star。</p><p>可以参考我之前的<a href="https://segmentfault.com/a/1190000007673785">博文</a>，即便是完全熟悉部署流程，不写脚本的情况下，如果纯手动 setup 或者 tear down 一个集群，都是比较耗时间的。</p><p>直到，发现了这个工具 kubeadm, 世界美好了。</p><p>这个工具对操作系统有限制， ubuntu 16.4 或 centos 7 以上。其实当初也看到了这个工具， 不过 因为系统限制，并且kubeadm还在alpha版本，又想手动撸一遍部署过程，所以没直接采用。 不过 kubeadm 不建议在生产环境中使用，在 官方文档中的 limitation 中有详细解释.</p><p><a href="https://kubernetes.io/docs/getting-started-guides/kubeadm/">文档</a> 中第一点就说了， kubeadm部署的是 single master，意味着不是高可用，谨慎使用。 但是作为演示实例再合适不过。</p><p>小插曲: 因为最近发布的 k8s 1.6 的 kubeadm 有一个bug，导致用以下步骤安装会有问题，为此社区里有人提了一个patch, 步骤有些多，我写在本文最后了。</p><p>开始部署步骤:</p><ol><li><p>在 Digital Ocean 中开三台机器, centos 7，建议2C2G，按小时计费用不了多少钱，用完就销毁。 如果还没有注册账号，并且觉得本文对你有帮助，可以用我的 referral link 注册，可以得到 10美金, <a href="https://m.do.co/c/821db079aed2">链接</a></p></li><li><p>登录三台机器，安装必要组件.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> centos 7</span></span><br><span class="line">yum clean</span><br><span class="line">yum update -y</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://yum.kubernetes.io/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span><br><span class="line">https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br><span class="line">yum install -y docker kubelet kubeadm kubectl kubernetes-cni</span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu 16.04</span></span><br><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb http://apt.kubernetes.io/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> Install docker <span class="keyword">if</span> you don<span class="string">&#x27;t have it already.</span></span></span><br><span class="line">apt-get install -y docker-engine</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl kubernetes-cni</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> add --authentication-token-webhook argument <span class="keyword">for</span> kubelet</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/silentred/k8s-tut</span></span><br></pre></td></tr></table></figure></li><li><p>选择一台作为master, 运行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">http://kubernetes.io/docs/admin/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node:</span><br><span class="line"></span><br><span class="line">kubeadm join --token=e344fa.e007ce406eb41f07 104.236.166.119</span><br></pre></td></tr></table></figure><p> 完成后会看到提示: <code>kubeadm join --token=311971.7260777a25d70ac8 104.236.166.119</code></p></li><li><p>在其他两台机器上分别运行以上提示的命令</p></li><li><p>在 master 上查看状态, <code>kubectl get nodes</code>, 如果看到一共有2个node，一个master， 则表示集群创建成功。</p></li></ol><h2 id="部署CNI网络"><a href="#部署CNI网络" class="headerlink" title="部署CNI网络"></a>部署CNI网络</h2><p>kubeadm 自动部署了一个插件，就是 kube-dns, 用于服务发现，但是到这里你会发现 kube-dns 这个服务没有启动成功，因为我们还没有部署CNI网络。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces | grep dns</span><br></pre></td></tr></table></figure><p>这里有比较多的选择，我使用了 calico，因为性能比较好，支持一键部署。 这里有一篇对比容器网络的文章，优缺点介绍比较全面， <a href="http://chunqi.li/2015/11/15/Battlefield-Calico-Flannel-Weave-and-Docker-Overlay-Network/">Battlefield: Calico, Flannel, Weave and Docker Overlay Network</a></p><p>配置文件在cni目录下，或者可以直接在master运行：<br><code>kubectl apply -f http://docs.projectcalico.org/v2.1/getting-started/kubernetes/installation/hosted/kubeadm/1.6/calico.yaml</code></p><p>再次查看 dns 服务是否运行成功吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按需安装 git 和 dig</span></span><br><span class="line">yum install -y bind-utils git </span><br></pre></td></tr></table></figure><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>在部署之前，我们需要对两台node标记角色，k8s是通过label来自定义各个资源的类型的。<br>首先确定两台node的name, 通过 <code>kubectl get nodes</code>来查看，之后挑选其中一台作为前端机器(frontend).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node centos-2gb-sfo1-03 role=frontend</span><br></pre></td></tr></table></figure><p>这里把centos-2gb-sfo2-node1换成你的 node name</p><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>应用 monitor 目录下的两个配置文件，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f prometheus.config.yaml</span><br><span class="line">kubectl create -f prometheus.deploy.yaml</span><br></pre></td></tr></table></figure><p>接下来打开 <a href="http://front-end-ip:30900/">http://front-end-ip:30900</a> 就能看到 prometheus 的界面</p><p><img src="/resource/image/prometheus.dash.png" alt="prometheus dashboard"></p><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f grafana.deploy.yaml</span><br></pre></td></tr></table></figure><p>打开 <a href="http://front-end-ip:30200/">http://front-end-ip:30200</a> 就能看到 grafana 的界面.</p><ol><li><p>还需要添加一个 Data Source. 选择 Promethues, 地址填上:<br> <a href="http://promethues:9090/">http://promethues:9090</a><br> 因为有kube-dns，所以这样就能访问 pod 中的 service</p><p> <img src="/resource/image/grafana.dash.png" alt="add data source"></p></li><li><p>添加模板，内容为  grafana.config.k8s.json, 这个模板是针对 k8s 集群的仪表模板，添加时选择对应的 Data Source，然后就能看到效果。<br> <img src="/resource/image/grafana.import.png" alt="add template"><br> <img src="/resource/image/grafana.k8s-cluster.png" alt="cluster"></p></li></ol><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>类似上面的步骤，配置文件在 gateway 目录下，运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f traefik.yaml</span><br></pre></td></tr></table></figure><p>这样在 <a href="http://front-end-ip:30088/">http://front-end-ip:30088</a> 能看到 网关的 dashboard。</p><p>traefik 可以监听 etcd 中注册的 ingress 的变化，根据 ingress 资源来自动配置路由， 下面会有具体的示例。最后的效果是， 后端服务的配置文件中定义他自己的 服务domain 和 prefix, traefik会自动添加这个路由, 这样就可以通过gateway来访问后端服务了。</p><h2 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h2><p>官方有推荐的Log系统: cAdvisor 和 Heapster.<br>我比较偏爱 ELK, 主要是生态比较好。有两种方式应用：</p><ol><li><p>第一种是每个Pod都多加一个 sidecar - Filebeat， 在每个后端服务配置文件中指定本地log的路径(利用 k8s 的 hostPath 这个volume)，在filebeat的配置中指定这个路径，实现日志收集</p></li><li><p>还有一种是Filebeat作为 DaemonSet 运行在每台机器, 这样每台机器只有一个 filebeat 运行，监听一个指定目录；后端服务约定好log都写入这个目录的子目录中，这样也能达到收集效果。</p></li></ol><p>我比较推荐第二种方式，工作量稍微小一些。</p><h2 id="第一个服务"><a href="#第一个服务" class="headerlink" title="第一个服务"></a>第一个服务</h2><p>终于到了这个紧张刺激的环节。</p><p>源文件在 hello-app 目录下，一个简单的 http service, 主要包含两个路由:</p><ol><li>/metrics 返回 prometheus 抓取的数据格式</li><li>/ 其他Path，返回一个随机id和URI</li></ol><p>log 日志输入 /tmp/hello-log/hello-app.log;</p><p>想要达到的效果是：</p><ol><li>配置文件中配好路由，自动注册到 gateway</li><li>promethues 自动发现服务，抓取 <a href="http://hello:8080/metrics">http://hello:8080/metrics</a> 的监控数据</li><li>日志能够自动收集</li></ol><p>app 的配置文件位于 hello-app 目录下, 运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f hello.yaml</span><br></pre></td></tr></table></figure><p>接着去 gateway 和 prometheus 的 dashboard 看下，会发现服务已经被发现;</p><p><img src="/resource/image/hello.gateway.png" alt="gateway"><br><img src="/resource/image/hello.prometheus.png" alt="prometheus"></p><p>再测试一下通过gateway是否能访问到 hello-app 这个服务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl http://front-end-ip:30087/v1/hello -H &#x27;Host: www.hello.local&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">结果为：</span></span><br><span class="line">ID:5577006791947779410 path:/hello</span><br></pre></td></tr></table></figure><h2 id="编译安装-kubeadm"><a href="#编译安装-kubeadm" class="headerlink" title="编译安装 kubeadm"></a>编译安装 kubeadm</h2><ol><li>下载 kubernetes 项目， checkout v1.6.0, 必须是这个tag</li><li><code>cherry-pick 89557110ed4693a7d23e515e738ced266e099365</code></li><li><code>KUBE_BUILD_PLATFORMS=linux/amd64 hack/make-rules/build.sh cmd/kubeadm</code></li><li>把生成的 _output 文件打包，放入服务器上</li><li>按照本文第一部分的步骤 yum 安装 docker, kubelet</li><li>编辑文件 <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code> 添加 参数<code>--cgroup-driver=systemd</code></li><li><code>sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart kubelet.service</code></li><li><code>kubeadm init</code> 能完成，但是 node 状态是 not-ready，因为 cni 没有配置.</li><li>复制 <code>/etc/kubernetes/admin.conf</code> 文件到 <code>~/.kube/config</code> 然后 执行 <code>kubectl get nodes</code>才可以，因为新版的apiserver启动时，把 insecure-port 禁用了，8080端口不再可用.</li></ol><h2 id="Alpine-Linux"><a href="#Alpine-Linux" class="headerlink" title="Alpine Linux"></a>Alpine Linux</h2><p>这次还遇到一个问题， alpine的docker镜像使用不顺利，ubuntu, centos下编译的文件在 alpine 下无法运行， 记得之前还运行成功过，这次得仔细找找原因。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul><li><p>水平扩展</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployments/hello --replicas=2 --record</span><br><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure></li><li><p>自动水平扩展</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale deployment hello --cpu-percent=10 --min=1 --max=2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> open another termial</span></span><br><span class="line">kubectl get hpa</span><br><span class="line">watch kubectl get pods</span><br><span class="line"></span><br><span class="line">while true; do wget -q -O- http://cluster-ip:8080; done</span><br></pre></td></tr></table></figure></li><li><p>升级一个项目 (rolling update)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">kubectl set image deployments/hello hello=silentred/hello-app:v3 --record</span><br><span class="line">kubectl rollout history deployments/hello // 查看历史</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">kubectl edit deployment/hello</span><br><span class="line">修改 image</span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">修改配置文件</span><br><span class="line">kubectl apply -f hello.yaml --record</span><br></pre></td></tr></table></figure></li><li><p>金丝雀部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不好用了</span><br><span class="line">kubectl set image deployments/hello hello=silentred/hello-app:v3; kubectl rollout pause deployments/hello</span><br><span class="line">kubectl rollout status deployments/hello</span><br><span class="line">kubectl rollout resume deployments/hello</span><br><span class="line"></span><br><span class="line">http://vishh.github.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments</span><br></pre></td></tr></table></figure></li><li><p>回滚 (rollback deployment)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployments/hello</span><br></pre></td></tr></table></figure></li><li><p>故障恢复 (pod / node)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop contaider-id</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何使用 kubernetes 部署微服务，包括 服务发现，监控，路由，日志。用实际的例子来演示自动化流程。主要分为以下几个部分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;5分钟搭建 K8S 集群&lt;/li&gt;
&lt;li&gt;部署 CNI 网络&lt;/li&gt;
&lt;li&gt;部署监控服务&lt;/li&gt;
&lt;li&gt;部署网关&lt;/li&gt;
&lt;li&gt;部署日志服务&lt;/li&gt;
&lt;li&gt;部署一个应用&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="kubernetes" scheme="http://localhost:4000/categories/tech/kubernetes/"/>
    
    
      <category term="microservice" scheme="http://localhost:4000/tags/microservice/"/>
    
      <category term="k8s" scheme="http://localhost:4000/tags/k8s/"/>
    
      <category term="devop" scheme="http://localhost:4000/tags/devop/"/>
    
  </entry>
  
  <entry>
    <title>fasthttp中的协程池实现</title>
    <link href="http://localhost:4000/2017/07/19/fasthttp/"/>
    <id>http://localhost:4000/2017/07/19/fasthttp/</id>
    <published>2017-07-19T05:24:43.000Z</published>
    <updated>2019-01-10T06:30:49.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>协程池可以控制并行度，复用协程。fasthttp 比 net/http 效率高很多倍的重要原因，就是利用了协程池。实现并不复杂，我们可以参考他的设计，写出高性能的应用。</p></blockquote><a id="more"></a><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Serve</span><span class="params">(ln net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lastOverflowErrorTime time.Time</span><br><span class="line">    <span class="keyword">var</span> lastPerIPErrorTime time.Time</span><br><span class="line">    <span class="keyword">var</span> c net.Conn</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    maxWorkersCount := s.getConcurrency()</span><br><span class="line">    s.concurrencyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, maxWorkersCount)</span><br><span class="line">    wp := &amp;workerPool&#123;</span><br><span class="line">        WorkerFunc:      s.serveConn,</span><br><span class="line">        MaxWorkersCount: maxWorkersCount,</span><br><span class="line">        LogAllErrors:    s.LogAllErrors,</span><br><span class="line">        Logger:          s.logger(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// break-00</span></span><br><span class="line">    wp.Start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// break-02</span></span><br><span class="line">        <span class="keyword">if</span> c, err = acceptConn(s, ln, &amp;lastPerIPErrorTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            wp.Stop()</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break-03</span></span><br><span class="line">        <span class="keyword">if</span> !wp.Serve(c) &#123;</span><br><span class="line">            s.writeFastError(c, StatusServiceUnavailable,</span><br><span class="line">                <span class="string">&quot;The connection cannot be served because Server.Concurrency limit exceeded&quot;</span>)</span><br><span class="line">            c.Close()</span><br><span class="line">            <span class="keyword">if</span> time.Since(lastOverflowErrorTime) &gt; time.Minute &#123;</span><br><span class="line">                s.logger().Printf(<span class="string">&quot;The incoming connection cannot be served, because %d concurrent connections are served. &quot;</span>+</span><br><span class="line">                    <span class="string">&quot;Try increasing Server.Concurrency&quot;</span>, maxWorkersCount)</span><br><span class="line">                lastOverflowErrorTime = CoarseTimeNow()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The current server reached concurrency limit,</span></span><br><span class="line">            <span class="comment">// so give other concurrently running servers a chance</span></span><br><span class="line">            <span class="comment">// accepting incoming connections on the same address.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// There is a hope other servers didn&#x27;t reach their</span></span><br><span class="line">            <span class="comment">// concurrency limits yet :)</span></span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有必要了解一下 workerPool 的结构</span></span><br><span class="line"><span class="keyword">type</span> workerPool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Function for serving server connections.</span></span><br><span class="line">    <span class="comment">// It must leave c unclosed.</span></span><br><span class="line">    WorkerFunc <span class="function"><span class="keyword">func</span><span class="params">(c net.Conn)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">    MaxWorkersCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    LogAllErrors <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    MaxIdleWorkerDuration time.Duration</span><br><span class="line"></span><br><span class="line">    Logger Logger</span><br><span class="line"></span><br><span class="line">    lock         sync.Mutex</span><br><span class="line">    workersCount <span class="keyword">int</span></span><br><span class="line">    mustStop     <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    ready []*workerChan</span><br><span class="line"></span><br><span class="line">    stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    workerChanPool sync.Pool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goroutine status:</p><ol><li>main0: wp.Start()</li></ol><h2 id="break-00"><a href="#break-00" class="headerlink" title="break-00"></a>break-00</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workerpool.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个 goroutine， 每隔一段时间，清理一下 []*workerChan; </span></span><br><span class="line"><span class="comment">// wp.clean() 的操作是 查看最近使用的workerChan, 如果他的最近使用间隔大于某个值，那么把这个workerChan清理了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> wp.stopCh != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;BUG: workerPool already started&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wp.stopCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    stopCh := wp.stopCh</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> scratch []*workerChan</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// break-01</span></span><br><span class="line">            wp.clean(&amp;scratch)</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                time.Sleep(wp.getMaxIdleWorkerDuration())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goroutine status:</p><ol><li>main0: wp.Start()</li><li>g1: for loop to clean idle workerChan</li></ol><h2 id="break-01"><a href="#break-01" class="headerlink" title="break-01"></a>break-01</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">clean</span><span class="params">(scratch *[]*workerChan)</span></span> &#123;</span><br><span class="line">    maxIdleWorkerDuration := wp.getMaxIdleWorkerDuration()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean least recently used workers if they didn&#x27;t serve connections</span></span><br><span class="line">    <span class="comment">// for more than maxIdleWorkerDuration.</span></span><br><span class="line">    currentTime := time.Now()</span><br><span class="line"></span><br><span class="line">    wp.lock.Lock()</span><br><span class="line">    ready := wp.ready</span><br><span class="line">    n := <span class="built_in">len</span>(ready)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 这里从队列头部取出超过 最大空闲时间 的workerChan。</span></span><br><span class="line">    <span class="comment">// 可以看出，最后使用的workerChan 一定是放回队列尾部的。</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; n &amp;&amp; currentTime.Sub(ready[i].lastUseTime) &gt; maxIdleWorkerDuration &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把空闲的放入 scratch, 剩余的放回 ready</span></span><br><span class="line">    *scratch = <span class="built_in">append</span>((*scratch)[:<span class="number">0</span>], ready[:i]...)</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        m := <span class="built_in">copy</span>(ready, ready[i:])</span><br><span class="line">        <span class="keyword">for</span> i = m; i &lt; n; i++ &#123;</span><br><span class="line">            ready[i] = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        wp.ready = ready[:m]</span><br><span class="line">    &#125;</span><br><span class="line">    wp.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify obsolete workers to stop.</span></span><br><span class="line">    <span class="comment">// This notification must be outside the wp.lock, since ch.ch</span></span><br><span class="line">    <span class="comment">// may be blocking and may consume a lot of time if many workers</span></span><br><span class="line">    <span class="comment">// are located on non-local CPUs.</span></span><br><span class="line">    tmp := *scratch</span><br><span class="line">    <span class="comment">// 销毁的操作就是向 chan net.Conn 中塞入一个 nil, 后面会看到解释</span></span><br><span class="line">    <span class="keyword">for</span> i, ch := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">        ch.ch &lt;- <span class="literal">nil</span></span><br><span class="line">        tmp[i] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-02"><a href="#break-02" class="headerlink" title="break-02"></a>break-02</h2><p><code>acceptConn(s, ln, &amp;lastPerIPErrorTime)</code> 主要处理 ln.Accept()，判断err是否是 Temporary 的，最终返回一个 net.Conn</p><h2 id="break-03"><a href="#break-03" class="headerlink" title="break-03"></a>break-03</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workerpool.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">Serve</span><span class="params">(c net.Conn)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// break-04</span></span><br><span class="line">    ch := wp.getCh()</span><br><span class="line">    <span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch.ch &lt;- c</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> workerChan <span class="keyword">struct</span> &#123;</span><br><span class="line">    lastUseTime time.Time</span><br><span class="line">    ch          <span class="keyword">chan</span> net.Conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wp.getCh() 返回一个 *workerChan, 可以看到， workerChan 有一个 ch 属性，参数传入的 net.Conn 直接往里面塞。</p><h2 id="break-04"><a href="#break-04" class="headerlink" title="break-04"></a>break-04</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workerpool.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">getCh</span><span class="params">()</span> *<span class="title">workerChan</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch *workerChan</span><br><span class="line">    createWorker := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    wp.lock.Lock()</span><br><span class="line">    ready := wp.ready</span><br><span class="line">    n := <span class="built_in">len</span>(ready) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// ready 为空，并且总数小于 MaxWorkersCount，那么需要创建新的 workerChan</span></span><br><span class="line">        <span class="keyword">if</span> wp.workersCount &lt; wp.MaxWorkersCount &#123;</span><br><span class="line">            createWorker = <span class="literal">true</span></span><br><span class="line">            wp.workersCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从队列尾部取出一个 workerChan</span></span><br><span class="line">        ch = ready[n]</span><br><span class="line">        ready[n] = <span class="literal">nil</span></span><br><span class="line">        wp.ready = ready[:n]</span><br><span class="line">    &#125;</span><br><span class="line">    wp.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ch == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !createWorker &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走入创建流程，从 Pool中取出 workerChan</span></span><br><span class="line">        vch := wp.workerChanPool.Get()</span><br><span class="line">        <span class="keyword">if</span> vch == <span class="literal">nil</span> &#123;</span><br><span class="line">            vch = &amp;workerChan&#123;</span><br><span class="line">                ch: <span class="built_in">make</span>(<span class="keyword">chan</span> net.Conn, workerChanCap),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ch = vch.(*workerChan)</span><br><span class="line">        <span class="comment">// 创建goroutine处理请求，接收一个 chan *workerChan 作为参数</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// break-05</span></span><br><span class="line">            wp.workerFunc(ch)</span><br><span class="line">            wp.workerChanPool.Put(vch)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只看创建的流程。如果ready为空，说明ready被耗尽，并且小于 MaxWorkersCount，那么需要创建新的 workerChan。<br>创建时，先从 Pool 中取出复用，如果为nil，再创建新的。<br>可以预测到，这里 wp.workerFunc(ch) 必定包含一个 for 循环，处理 workerChan 中的 net.Conn。</p><p>goroutine status:</p><ol><li>main0: wp.Start()</li><li>g1: for loop to clean idle workerChan</li><li>g2: wp.workerFunc(ch) blocks for handling connection</li></ol><h2 id="break-05"><a href="#break-05" class="headerlink" title="break-05"></a>break-05</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workerpool.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">workerFunc</span><span class="params">(ch *workerChan)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c net.Conn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> c = <span class="keyword">range</span> ch.ch &#123;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正真的处理请求的函数</span></span><br><span class="line">        <span class="keyword">if</span> err = wp.WorkerFunc(c); err != <span class="literal">nil</span> &amp;&amp; err != errHijacked &#123;</span><br><span class="line">            errStr := err.Error()</span><br><span class="line">            <span class="keyword">if</span> wp.LogAllErrors || !(strings.Contains(errStr, <span class="string">&quot;broken pipe&quot;</span>) ||</span><br><span class="line">                strings.Contains(errStr, <span class="string">&quot;reset by peer&quot;</span>) ||</span><br><span class="line">                strings.Contains(errStr, <span class="string">&quot;i/o timeout&quot;</span>)) &#123;</span><br><span class="line">                wp.Logger.Printf(<span class="string">&quot;error when serving connection %q&lt;-&gt;%q: %s&quot;</span>, c.LocalAddr(), c.RemoteAddr(), err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != errHijacked &#123;</span><br><span class="line">            c.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放 workerChan</span></span><br><span class="line">        <span class="comment">// break-06</span></span><br><span class="line">        <span class="keyword">if</span> !wp.release(ch) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳出 for range 循环， 意味着 从chan中取得一个 nil，或者 wp.mustStop 被设为了true，这是主动停止的方法。</span></span><br><span class="line">    wp.lock.Lock()</span><br><span class="line">    wp.workersCount--</span><br><span class="line">    wp.lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for range 不断从 chan net.Conn 中获取连接。大家是否还记得 在 <code>func (wp *workerPool) Serve(c net.Conn) bool</code> 函数中，一个重要操作就是把 accept 到的connection，放入 channel.<br>最后，需要把当前的 workerChan 释放回 workerPool 的 ready 中。</p><h2 id="break-06"><a href="#break-06" class="headerlink" title="break-06"></a>break-06</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">release</span><span class="params">(ch *workerChan)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ch.lastUseTime = CoarseTimeNow()</span><br><span class="line">    wp.lock.Lock()</span><br><span class="line">    <span class="keyword">if</span> wp.mustStop &#123;</span><br><span class="line">        wp.lock.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    wp.ready = <span class="built_in">append</span>(wp.ready, ch)</span><br><span class="line">    wp.lock.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放操作中，注意到 修改了 ch.lastUseTime ， 还记得 clean 操作吗？在 g1 协程中运行着呢。<br>所以最后的运行状态是：</p><p>goroutine status:</p><ol><li>main0: wp.Start()</li><li>g1: for loop to clean idle workerChan</li><li>g2: wp.workerFunc(ch) blocks for handling connection</li><li>g3: …. </li><li>g4: ….</li></ol><p>按需增长 goroutine 数量，但是也有一个最大值, 所以并行度是可控的。当请求密集时，一个 worker goroutine 可能会串行处理多个 connection。<br>wokerChan 在 Pool 中被复用，对GC的压力会减小很多。</p><p>而对比原生的 net/http 包，并行度不可控（可能不确定，runtime 会有控制? ），goroutine 不可被复用，体现在一个请求一个goroutine, 用完就销毁了，对机器压力更大。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;协程池可以控制并行度，复用协程。fasthttp 比 net/http 效率高很多倍的重要原因，就是利用了协程池。实现并不复杂，我们可以参考他的设计，写出高性能的应用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="golang" scheme="http://localhost:4000/categories/tech/golang/"/>
    
    
      <category term="golang" scheme="http://localhost:4000/tags/golang/"/>
    
      <category term="goroutine" scheme="http://localhost:4000/tags/goroutine/"/>
    
      <category term="web" scheme="http://localhost:4000/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Golang模仿七牛图片处理API</title>
    <link href="http://localhost:4000/2017/07/18/qiniu-image-handle/"/>
    <id>http://localhost:4000/2017/07/18/qiniu-image-handle/</id>
    <published>2017-07-18T07:55:48.000Z</published>
    <updated>2019-01-10T06:30:49.252Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前一直在用qiniu的存储服务，生成图片的缩略图，模糊图，视频的webp，现在需要把存储移到s3上，那么这些图片，视频处理就要自己动手写了，本文梳理一下大致的思路。</p></blockquote><a id="more"></a><h2 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h2><p>先看一下qiniu的接口是如何处理图片的，例如先截取视频第一秒的图片，再把图片缩略，最后存储到一个新的key，命令可以这么写 <code>vframe/jpg/offset/1|imageMogr2/thumbnail/400x|saveas/xxx</code>, 可以看到三个操作之间用 <code>|</code> 符号分割，类似unix 的 pipe 操作。</p><p>上面的操作算作一个<code>cmd</code>, 一次API请求可以同时处理多个<code>cmd</code>，<code>cmd</code>之间用分号分割, 处理完毕后，在回调中把处理结果返回，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;xxxxx&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;pipeline&quot;</span>: <span class="string">&quot;xxx&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">0</span>, </span><br><span class="line">    <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;The fop was completed successfully&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;reqid&quot;</span>: <span class="string">&quot;xTsAAFnxUbR5J10U&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;inputBucket&quot;</span>: <span class="string">&quot;xxx&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;inputKey&quot;</span>: <span class="string">&quot;xxxxx&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;items&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;cmd&quot;</span>: <span class="string">&quot;vframe/jpg/offset/1|imageMogr2/thumbnail/400x|saveas/ZmFtZS1wcml2YXRlOm1vbWVudC9jb3Zlci9zbmFwL3ZpZGVvL2M5YzdjZjQ5LTU3NGQtNGZjMS1iZDFkLTRkYjZkMzlkZWY1Ni8wLzA=&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;code&quot;</span>: <span class="number">0</span>, </span><br><span class="line">            <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;The fop was completed successfully&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;hash&quot;</span>: <span class="string">&quot;FhdN6V8EI4vW4XJGALSfxutvMEIv&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xx&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;returnOld&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;cmd&quot;</span>: <span class="string">&quot;vframe/jpg/offset/1|imageMogr2/thumbnail/400x|imageMogr2/blur/45x8|saveas/ZmFtZS1wcml2YXRlOm1vbWVudC9jb3Zlci9zbmFwL3ZpZGVvL2M5YzdjZjQ5LTU3NGQtNGZjMS1iZDFkLTRkYjZkMzlkZWY1Ni8wLzBfYmx1cg==&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;code&quot;</span>: <span class="number">0</span>, </span><br><span class="line">            <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;The fop was completed successfully&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;hash&quot;</span>: <span class="string">&quot;FgNiRzrCsa7TZx1xVSb_4d5TiaK3&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;xxx&quot;</span>, </span><br><span class="line">            <span class="attr">&quot;returnOld&quot;</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分解需求"><a href="#分解需求" class="headerlink" title="分解需求"></a>分解需求</h2><p>这个程序大致需要这么几个部分:</p><ol><li><p>一个http接口，接受任务，接受后把任务扔到队列，返回一个job ID。 worker异步处理任务，worker的个数 和 每个worker 并行的处理的个数 能够配置，worker有重试机制。</p></li><li><p>从 job payload 中解析出需要做的任务，解析出每个cmd, 最好能并行执行每一个 cmd, 记录每一个cmd的结果</p></li><li><p>每个cmd中有多个 <code>operation</code>, 并且用 pipe 连接，前一个operaion的输出是后一个operation的输入</p></li></ol><p>可以把 1 和 2，3 分开来看，1 比较独立，之前写过一个worker的模型，参考的是这篇文章 <a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/">Handling 1 Million Requests per Minute with Go</a>，比较详细，是用 go channel 作为queue的，我加了一个 beanstalk 作为 queue的 providor。还有一点改进是，文章中只提供了worker数量的设置，我再加了一个参数，设定每个worker可以并行执行的协程数。所以下面主要讲讲3， 2的解决办法</p><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>可以参考这个库 <a href="http://gopkg.in/pipe.v2">pipe</a>, 用法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p := pipe.Line(</span><br><span class="line">    pipe.ReadFile(<span class="string">&quot;test.png&quot;</span>),</span><br><span class="line">    resize(<span class="number">300</span>, <span class="number">300</span>),</span><br><span class="line">    blur(<span class="number">0.5</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">output, err := pipe.CombinedOutput(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf := bytes.NewBuffer(output)</span><br><span class="line">img, _ := imaging.Decode(buf)</span><br><span class="line"></span><br><span class="line">imaging.Save(img, <span class="string">&quot;test_a.png&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是比较方便的，建一个 <code>Cmd</code> struct, 利用正则匹配一下每个 <code>Operation</code> 的参数，放入一个 <code>[]Op</code> slice, 最后执行，struct和方法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cmd <span class="keyword">struct</span> &#123;</span><br><span class="line">    cmd    <span class="keyword">string</span></span><br><span class="line">    saveas <span class="keyword">string</span></span><br><span class="line">    ops    []Op</span><br><span class="line">    err    error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Op <span class="keyword">interface</span> &#123;</span><br><span class="line">    getPipe() pipe.Pipe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResizeOp <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ResizeOp)</span> <span class="title">getPipe</span><span class="params">()</span> <span class="title">pipe</span>.<span class="title">Pipe</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resize(c.width, c.height)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">cmdStr := <span class="string">`file/test.png|thumbnail/x300|blur/20x8`</span></span><br><span class="line">cmd := Cmd&#123;cmdStr, <span class="string">&quot;test_b.png&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">cmd.parse()</span><br><span class="line">cmd.doOps()</span><br></pre></td></tr></table></figure><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>单个cmd处理解决后，就是多个cmd的并行问题，没啥好想的，直接用 <code>sync.WaitGroup</code> 就可以完美解决。一步一步来，我们先看看这个struct的使用方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmds := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        cmds = <span class="built_in">append</span>(cmds, fmt.Sprintf(<span class="string">&quot;cmd-%d&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results := handleCmds(cmds)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(results)) <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doCmd</span><span class="params">(cmd <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;cmd=%s&quot;</span>, cmd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleCmds</span><span class="params">(cmds []<span class="keyword">string</span>)</span> <span class="params">(results []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(cmds)) <span class="comment">//10000</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    group := sync.WaitGroup&#123;&#125;</span><br><span class="line">    lock := sync.Mutex&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> cmds &#123;</span><br><span class="line">        <span class="comment">// 计数加一</span></span><br><span class="line">        group.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cmd <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            result := doCmd(cmd)</span><br><span class="line">            atomic.AddUint64(&amp;count, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            lock.Lock()</span><br><span class="line">            results = <span class="built_in">append</span>(results, result)</span><br><span class="line">            lock.Unlock()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计数减一</span></span><br><span class="line">            group.Done()</span><br><span class="line">        &#125;(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞</span></span><br><span class="line">    group.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;count=%d \n&quot;</span>, count) <span class="comment">// 10000</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>group本质大概是一个计数器，计数 &gt; 0时, <code>group.Wait()</code> 会阻塞，直到 计数 == 0. 这里还有一点要注意，就是 <code>results = append(results, result)</code> 的操作是线程不安全的，清楚这里 results 是共享的，需要加锁来保证同步，否则最后 <code>len(results)</code> 不为 10000。</p><p>我们建一个<code>BenchCmd</code>， 来存放 cmds. 如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BenchCmd <span class="keyword">struct</span> &#123;</span><br><span class="line">    cmds      []Cmd</span><br><span class="line">    waitGroup sync.WaitGroup</span><br><span class="line">    errs      []error</span><br><span class="line">    lock      sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BenchCmd)</span> <span class="title">doCmds</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> b.cmds &#123;</span><br><span class="line">        b.waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cmd Cmd)</span></span> &#123;</span><br><span class="line">            cmd.parse()</span><br><span class="line">            err := cmd.doOps()</span><br><span class="line"></span><br><span class="line">            b.lock.Lock()</span><br><span class="line">            b.errs = <span class="built_in">append</span>(b.errs, err)</span><br><span class="line">            b.lock.Unlock()</span><br><span class="line"></span><br><span class="line">            b.waitGroup.Done()</span><br><span class="line">        &#125;(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b.waitGroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的调用就像这样：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmds []Cmd</span><br><span class="line">cmd_a := Cmd&#123;<span class="string">`file/test.png|thumbnail/x300|blur/20x8`</span>, <span class="string">&quot;test_a.png&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">cmd_b := Cmd&#123;<span class="string">`file/test.png|thumbnail/500x1000|blur/20x108`</span>, <span class="string">&quot;test_b.png&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">cmd_c := Cmd&#123;<span class="string">`file/test.png|thumbnail/300x300`</span>, <span class="string">&quot;test_c.png&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">cmds = <span class="built_in">append</span>(cmds, cmd_a)</span><br><span class="line">cmds = <span class="built_in">append</span>(cmds, cmd_b)</span><br><span class="line">cmds = <span class="built_in">append</span>(cmds, cmd_c)</span><br><span class="line"></span><br><span class="line">bench := BenchCmd&#123;</span><br><span class="line">    cmds:      cmds,</span><br><span class="line">    waitGroup: sync.WaitGroup&#123;&#125;,</span><br><span class="line">    lock:      sync.Mutex&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bench.doCmds()</span><br><span class="line"></span><br><span class="line">fmt.Println(bench.errs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这只是一个初级的实验，思考还不够全面，并且只是模仿API，qiniu应该不是这么做的，耦合更低，可能各个Cmd都有各自处理的集群，那<code>pipe</code>这个库就暂时没法解决了，目前的局限在于 每个Cmd必须都在一个进程中。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前一直在用qiniu的存储服务，生成图片的缩略图，模糊图，视频的webp，现在需要把存储移到s3上，那么这些图片，视频处理就要自己动手写了，本文梳理一下大致的思路。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://localhost:4000/categories/tech/"/>
    
      <category term="golang" scheme="http://localhost:4000/categories/tech/golang/"/>
    
    
      <category term="golang" scheme="http://localhost:4000/tags/golang/"/>
    
      <category term="image" scheme="http://localhost:4000/tags/image/"/>
    
  </entry>
  
</feed>
